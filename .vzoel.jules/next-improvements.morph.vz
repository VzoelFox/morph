# Rekomendasi Pengembangan Lanjutan

Dokumen ini berisi saran detail untuk pengembangan masa depan.

## Current Status (2025-12-26 14:46)

### âœ… COMPLETED
- **Phase 1-7**: Full self-hosting achieved, GO compiler retired
- **Memory System**: Fixed GC thresholds (1MB/256KB) untuk development
- **Import System**: Working dengan capitalized function exports
- **String & Logic**: Essential functions implemented untuk tree walker
- **MorphFox N3**: Clean architecture dengan zero C dependency target

### ðŸŽ¯ N3 TREE WALKER PRIORITY (HIGH)

#### 1. Tree Walker Implementation
- Port morphsh tree_walker.fox ke morphfox
- Use essential functions: IntToString, BoolToString, StringEquals
- Implement single-file approach untuk bypass import complexity
- Test dengan basic AST evaluation

#### 2. Self-Compilation Test
- Test N3 compile dirinya sendiri
- Verify pure Morph output generation
- Benchmark performance vs N1 compiler

#### 3. Production Readiness
- Restore GC thresholds ke production values (64MB/8MB)
- Remove DEBUG prints
- Performance optimization

## Analysis Tool Enhancements

### 1. Closure Detection
Saat ini `isDefined` hanya mengecek keberadaan variabel di stack. Sebaiknya hitung `depth`. Jika `depth > 0` (bukan scope lokal saat ini), tandai sebagai `Captured Variable`.

### 2. Nested Function Handling
Gunakan key unik untuk nested function di `context.Symbols`.
Format saran: `parentFunction.childFunction`.

### 3. Type Inference
Implementasi `inferBinaryOpType` yang menangani koersi tipe:
- `String + String` -> `String`
- `Int + Float` -> `Float`
- `Bool` ops -> `Bool`

### 4. Control Flow & Dead Code
- **Unreachable Code**: Deteksi statement setelah `kembalikan` (return) atau `berhenti` (break).
- **Unused Var**: Track definisi variabel dan penggunaannya. Laporkan jika defined but not used.

### 5. Complexity Metrics
Hitung Cyclomatic Complexity per fungsi, bukan akumulasi global. Simpan di `Symbol.Complexity`.

### 6. Data Flow
Implementasi Liveness Analysis (Live-in/Live-out sets) untuk optimasi register allocation nantinya (saat masuk fase LLVM).
