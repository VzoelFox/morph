ambil "morphsh/ast"
ambil "morphsh/lexer"
ambil "morphsh/token"

struktur Parser
    lexer Lexer
    current Token
    peek Token
    errors []string
akhir

fungsi NewParser(l Lexer) Parser
    var p = Parser{lexer: l, current: Token{Type: ILLEGAL}, peek: Token{Type: ILLEGAL}, errors: []}
    p.nextToken()
    p.nextToken()
    kembali p
akhir

fungsi (p *Parser) Errors() []string
    kembali p.errors
akhir

fungsi (p *Parser) addError(msg string) void
    p.errors = p.errors + [msg]
akhir

fungsi (p *Parser) nextToken() void
    p.current = p.peek
    p.peek = p.lexer.NextToken()
akhir

fungsi (p *Parser) ParseProgram() Program
    var program = Program{token: p.current, statements: NewNodeList()}

    selama p.current.Type != EOF
        var stmt = p.parseStatement()
        jika stmt != kosong
            program.statements = AddNode(program.statements, stmt)
        akhir
        p.nextToken()
    akhir

    kembali program
akhir

tetapan PREC_LOWEST = 1
tetapan PREC_EQUALS = 2
tetapan PREC_COMPARE = 3
tetapan PREC_SUM = 4
tetapan PREC_PRODUCT = 5
tetapan PREC_PREFIX = 6
tetapan PREC_CALL = 7

var precedences map[string]int = {
    EQ: PREC_EQUALS,
    NOT_EQ: PREC_EQUALS,
    LT: PREC_COMPARE,
    LTE: PREC_COMPARE,
    GT: PREC_COMPARE,
    GTE: PREC_COMPARE,
    PLUS: PREC_SUM,
    MINUS: PREC_SUM,
    ASTERISK: PREC_PRODUCT,
    SLASH: PREC_PRODUCT,
    PERCENT: PREC_PRODUCT,
    LPAREN: PREC_CALL,
}

fungsi (p *Parser) parseStatement() Node
    jika p.current.Type == VAR atau p.current.Type == TETAPAN
        kembali p.parseVarStatement()
    akhir
    jika p.current.Type == KEMBALIKAN
        kembali p.parseReturnStatement()
    akhir

    kembali p.parseExpressionStatement()
akhir

fungsi (p *Parser) parseReturnStatement() Node
    var stmt = ReturnStatement{token: p.current, value: kosong}

    jika p.peek.Type == SEMICOLON
        p.nextToken()
        kembali stmt
    akhir

    p.nextToken()
    stmt.value = p.parseExpression()

    jika p.peek.Type == SEMICOLON
        p.nextToken()
    akhir

    kembali stmt
akhir

fungsi (p *Parser) parseVarStatement() Node
    var stmt = VarStatement{token: p.current, name: Identifier{token: Token{}, value: ""}, value: kosong, isConst: p.current.Type == TETAPAN}

    jika !p.expectPeek(IDENT)
        kembali stmt
    akhir

    stmt.name = Identifier{token: p.current, value: p.current.Literal}

    jika p.peek.Type == ASSIGN
        p.nextToken()
        p.nextToken()
        stmt.value = p.parseExpression()
    akhir

    jika p.peek.Type == SEMICOLON
        p.nextToken()
    akhir

    kembali stmt
akhir

fungsi (p *Parser) parseExpressionStatement() Node
    var stmt = ExpressionStatement{token: p.current, expression: p.parseExpression()}

    jika p.peek.Type == SEMICOLON
        p.nextToken()
    akhir

    kembali stmt
akhir

fungsi (p *Parser) parseExpression() Node
    kembali p.parseExpressionWithPrecedence(PREC_LOWEST)
akhir

fungsi (p *Parser) parseExpressionWithPrecedence(precedence int) Node
    var left = p.parsePrefixExpression()
    jika left == kosong
        kembali kosong
    akhir

    selama p.peek.Type != SEMICOLON dan precedence < p.peekPrecedence()
        jika !isInfixToken(p.peek.Type)
            kembali left
        akhir
        p.nextToken()
        left = p.parseInfixExpression(left)
    akhir

    kembali left
akhir

fungsi (p *Parser) parsePrefixExpression() Node
    jika p.current.Type == IDENT
        kembali Identifier{token: p.current, value: p.current.Literal}
    akhir
    jika p.current.Type == INT
        kembali IntegerLiteral{token: p.current, value: p.current.Literal}
    akhir
    jika p.current.Type == FLOAT
        kembali FloatLiteral{token: p.current, value: p.current.Literal}
    akhir
    jika p.current.Type == STRING
        kembali StringLiteral{token: p.current, value: p.current.Literal}
    akhir
    jika p.current.Type == BENAR
        kembali BooleanLiteral{token: p.current, value: benar}
    akhir
    jika p.current.Type == SALAH
        kembali BooleanLiteral{token: p.current, value: salah}
    akhir
    jika p.current.Type == KOSONG
        kembali NullLiteral{token: p.current}
    akhir
    jika p.current.Type == JIKA
        kembali p.parseIfExpression()
    akhir
    jika p.current.Type == SELAMA
        kembali p.parseWhileExpression()
    akhir
    jika p.current.Type == BANG atau p.current.Type == MINUS
        var token = p.current
        var op = p.current.Literal
        p.nextToken()
        var right = p.parseExpressionWithPrecedence(PREC_PREFIX)
        kembali PrefixExpression{token: token, operator: op, right: right}
    akhir
    jika p.current.Type == LPAREN
        kembali p.parseGroupedExpression()
    akhir

    p.addError("parser: expression belum diimplementasi untuk token " + p.current.Type)
    kembali kosong
akhir

fungsi (p *Parser) parseGroupedExpression() Node
    p.nextToken()
    var exp = p.parseExpressionWithPrecedence(PREC_LOWEST)
    jika !p.expectPeek(RPAREN)
        kembali kosong
    akhir
    kembali exp
akhir

fungsi (p *Parser) parseInfixExpression(left Node) Node
    jika p.current.Type == LPAREN
        kembali p.parseCallExpression(left)
    akhir

    var token = p.current
    var op = p.current.Literal
    var precedence = p.currentPrecedence()
    p.nextToken()
    var right = p.parseExpressionWithPrecedence(precedence)
    kembali InfixExpression{token: token, left: left, operator: op, right: right}
akhir

fungsi (p *Parser) parseCallExpression(fn Node) Node
    var call = CallExpression{token: p.current, function: fn, arguments: NewNodeList()}
    call.arguments = p.parseExpressionList(RPAREN)
    kembali call
akhir

fungsi (p *Parser) parseExpressionList(end string) NodeList
    var list = NewNodeList()
    jika p.peek.Type == end
        p.nextToken()
        kembali list
    akhir

    p.nextToken()
    var arg = p.parseExpressionWithPrecedence(PREC_LOWEST)
    jika arg != kosong
        list = AddNode(list, arg)
    akhir

    selama p.peek.Type == COMMA
        p.nextToken()
        p.nextToken()
        var nextArg = p.parseExpressionWithPrecedence(PREC_LOWEST)
        jika nextArg != kosong
            list = AddNode(list, nextArg)
        akhir
    akhir

    jika !p.expectPeek(end)
        kembali list
    akhir

    kembali list
akhir

fungsi (p *Parser) parseIfExpression() Node
    var exp = IfExpression{
        token: p.current,
        condition: kosong,
        consequence: BlockStatement{token: Token{}, statements: NewNodeList()},
        alternative: BlockStatement{token: Token{}, statements: NewNodeList()},
        hasAlternative: salah,
    }

    p.nextToken()
    exp.condition = p.parseExpressionWithPrecedence(PREC_LOWEST)

    p.nextToken()
    exp.consequence = p.parseBlockStatement()

    jika p.current.Type == LAINNYA
        exp.hasAlternative = benar
        p.nextToken()
        exp.alternative = p.parseBlockStatement()
    akhir

    jika p.current.Type != AKHIR
        p.addError("parser: expected 'akhir' after if expression")
    akhir

    kembali exp
akhir

fungsi (p *Parser) parseWhileExpression() Node
    var exp = WhileExpression{
        token: p.current,
        condition: kosong,
        body: BlockStatement{token: Token{}, statements: NewNodeList()},
    }

    p.nextToken()
    exp.condition = p.parseExpressionWithPrecedence(PREC_LOWEST)

    p.nextToken()
    exp.body = p.parseBlockStatement()

    jika p.current.Type != AKHIR
        p.addError("parser: expected 'akhir' after while expression")
    akhir

    kembali exp
akhir

fungsi (p *Parser) parseBlockStatement() BlockStatement
    var block = BlockStatement{token: p.current, statements: NewNodeList()}

    selama p.current.Type != AKHIR dan p.current.Type != LAINNYA dan p.current.Type != EOF
        var stmt = p.parseStatement()
        jika stmt != kosong
            block.statements = AddNode(block.statements, stmt)
        akhir
        p.nextToken()
    akhir

    kembali block
akhir

fungsi (p *Parser) peekPrecedence() int
    var prec = precedences[p.peek.Type]
    jika prec != 0
        kembali prec
    akhir
    kembali PREC_LOWEST
akhir

fungsi (p *Parser) currentPrecedence() int
    var prec = precedences[p.current.Type]
    jika prec != 0
        kembali prec
    akhir
    kembali PREC_LOWEST
akhir

fungsi isInfixToken(t string) bool
    jika t == PLUS atau t == MINUS atau t == ASTERISK atau t == SLASH atau t == PERCENT
        kembali benar
    akhir
    jika t == EQ atau t == NOT_EQ atau t == LT atau t == LTE atau t == GT atau t == GTE
        kembali benar
    akhir
    jika t == LPAREN
        kembali benar
    akhir
    kembali salah
akhir

fungsi (p *Parser) expectPeek(t string) bool
    jika p.peek.Type == t
        p.nextToken()
        kembali benar
    akhir

    p.addError("parser: expected next token " + t + ", got " + p.peek.Type)
    kembali salah
akhir
