# enhanced_checker.fox - Enhanced type checker with better Go consistency
ambil "io"

# Type system yang lebih lengkap
struktur Type
    kind int
    name string
    element_type int  # For arrays/maps
    key_type int      # For maps
akhir

# Type kinds (consistent with Go implementation)
tetapan KIND_INT = 0
tetapan KIND_FLOAT = 1
tetapan KIND_STRING = 2
tetapan KIND_BOOL = 3
tetapan KIND_VOID = 4
tetapan KIND_ARRAY = 5
tetapan KIND_MAP = 6
tetapan KIND_FUNCTION = 7
tetapan KIND_ERROR = 8

# Enhanced checker with scope management
struktur EnhancedChecker
    errors [string]
    warnings [string]
    current_scope int
    scope_depth int
    return_stack [Type]
    builtin_functions [string]
akhir

# Create enhanced checker
fungsi new_enhanced_checker() EnhancedChecker
    var checker = EnhancedChecker{
        errors: [],
        warnings: [],
        current_scope: 0,
        scope_depth: 0,
        return_stack: [],
        builtin_functions: []
    }
    
    # Register built-in functions (like Go implementation)
    checker = register_builtins(checker)
    
    kembali checker
akhir

# Register built-in functions (consistent with Go)
fungsi register_builtins(checker EnhancedChecker) EnhancedChecker
    var builtins = checker.builtin_functions
    
    # Core built-ins from Go implementation
    builtins = builtins + ["parse_int"]
    builtins = builtins + ["native_print"]
    builtins = builtins + ["native_print_int"]
    builtins = builtins + ["index"]
    builtins = builtins + ["trim"]
    builtins = builtins + ["split"]
    builtins = builtins + ["substring"]
    builtins = builtins + ["len"]
    
    var updated_checker = EnhancedChecker{
        errors: checker.errors,
        warnings: checker.warnings,
        current_scope: checker.current_scope,
        scope_depth: checker.scope_depth,
        return_stack: checker.return_stack,
        builtin_functions: builtins
    }
    
    kembali updated_checker
akhir

# Enhanced binary expression checking (more consistent with Go)
fungsi check_binary_enhanced(checker EnhancedChecker, left_type Type, op string, right_type Type) Type
    # Arithmetic operators - strict type checking like Go
    jika op == "+"
        # int + int = int
        jika left_type.kind == KIND_INT dan right_type.kind == KIND_INT
            kembali Type{kind: KIND_INT, name: "int", element_type: 0, key_type: 0}
        akhir
        # string + string = string
        jika left_type.kind == KIND_STRING dan right_type.kind == KIND_STRING
            kembali Type{kind: KIND_STRING, name: "string", element_type: 0, key_type: 0}
        akhir
        # float + float = float
        jika left_type.kind == KIND_FLOAT dan right_type.kind == KIND_FLOAT
            kembali Type{kind: KIND_FLOAT, name: "float", element_type: 0, key_type: 0}
        akhir
        # Type mismatch error
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    jika op == "-" atau op == "*" atau op == "/" atau op == "%"
        # Only numeric types
        jika left_type.kind == KIND_INT dan right_type.kind == KIND_INT
            kembali Type{kind: KIND_INT, name: "int", element_type: 0, key_type: 0}
        akhir
        jika left_type.kind == KIND_FLOAT dan right_type.kind == KIND_FLOAT
            kembali Type{kind: KIND_FLOAT, name: "float", element_type: 0, key_type: 0}
        akhir
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Comparison operators - return bool
    jika op == "==" atau op == "!=" atau op == "<" atau op == ">" atau op == "<=" atau op == ">="
        # Can compare same types
        jika left_type.kind == right_type.kind
            kembali Type{kind: KIND_BOOL, name: "bool", element_type: 0, key_type: 0}
        akhir
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Logical operators
    jika op == "dan" atau op == "atau"
        jika left_type.kind == KIND_BOOL dan right_type.kind == KIND_BOOL
            kembali Type{kind: KIND_BOOL, name: "bool", element_type: 0, key_type: 0}
        akhir
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Default error
    kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
akhir

# Array type checking (consistent with Go)
fungsi check_array_access(checker EnhancedChecker, array_type Type, index_type Type) Type
    # Array must be array type
    jika array_type.kind != KIND_ARRAY
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Index must be int
    jika index_type.kind != KIND_INT
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Return element type
    kembali Type{kind: array_type.element_type, name: "element", element_type: 0, key_type: 0}
akhir

# Map type checking (consistent with Go)
fungsi check_map_access(checker EnhancedChecker, map_type Type, key_type Type) Type
    # Map must be map type
    jika map_type.kind != KIND_MAP
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Key type must match
    jika key_type.kind != map_type.key_type
        kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
    akhir
    
    # Return value type
    kembali Type{kind: map_type.element_type, name: "value", element_type: 0, key_type: 0}
akhir

# Function call checking (consistent with Go)
fungsi check_function_call(checker EnhancedChecker, func_name string, arg_types [Type]) Type
    # Check if it's a built-in function
    var is_builtin = salah
    var i = 0
    selama i < len(checker.builtin_functions)
        jika checker.builtin_functions[i] == func_name
            is_builtin = benar
            break
        akhir
        i = i + 1
    akhir
    
    jika is_builtin
        # Built-in function type checking
        jika func_name == "len"
            # len(array/string) -> int
            jika len(arg_types) == 1
                var arg = arg_types[0]
                jika arg.kind == KIND_ARRAY atau arg.kind == KIND_STRING
                    kembali Type{kind: KIND_INT, name: "int", element_type: 0, key_type: 0}
                akhir
            akhir
            kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
        akhir
        
        jika func_name == "parse_int"
            # parse_int(string) -> (int, string)
            jika len(arg_types) == 1 dan arg_types[0].kind == KIND_STRING
                kembali Type{kind: KIND_INT, name: "int", element_type: 0, key_type: 0}
            akhir
            kembali Type{kind: KIND_ERROR, name: "error", element_type: 0, key_type: 0}
        akhir
        
        # Default built-in returns void
        kembali Type{kind: KIND_VOID, name: "void", element_type: 0, key_type: 0}
    akhir
    
    # User-defined function - assume void for now
    kembali Type{kind: KIND_VOID, name: "void", element_type: 0, key_type: 0}
akhir

# Test enhanced checker
fungsi test_enhanced_checker() void
    io.Write(io.Stdout, "=== ENHANCED CHECKER TEST ===\n")
    
    var checker = new_enhanced_checker()
    
    # Test binary operations
    var int_type = Type{kind: KIND_INT, name: "int", element_type: 0, key_type: 0}
    var string_type = Type{kind: KIND_STRING, name: "string", element_type: 0, key_type: 0}
    
    var add_result = check_binary_enhanced(checker, int_type, "+", int_type)
    jika add_result.kind == KIND_INT
        io.Write(io.Stdout, "int + int = int: ‚úÖ PASS\n")
    lainnya
        io.Write(io.Stdout, "int + int: ‚ùå FAIL\n")
    akhir
    
    var concat_result = check_binary_enhanced(checker, string_type, "+", string_type)
    jika concat_result.kind == KIND_STRING
        io.Write(io.Stdout, "string + string = string: ‚úÖ PASS\n")
    lainnya
        io.Write(io.Stdout, "string + string: ‚ùå FAIL\n")
    akhir
    
    var compare_result = check_binary_enhanced(checker, int_type, "==", int_type)
    jika compare_result.kind == KIND_BOOL
        io.Write(io.Stdout, "int == int = bool: ‚úÖ PASS\n")
    lainnya
        io.Write(io.Stdout, "int == int: ‚ùå FAIL\n")
    akhir
    
    # Test array access
    var array_type = Type{kind: KIND_ARRAY, name: "array", element_type: KIND_INT, key_type: 0}
    var array_access_result = check_array_access(checker, array_type, int_type)
    jika array_access_result.kind == KIND_INT
        io.Write(io.Stdout, "array[int] = int: ‚úÖ PASS\n")
    lainnya
        io.Write(io.Stdout, "array[int]: ‚ùå FAIL\n")
    akhir
    
    # Test function calls
    var len_args = [string_type]
    var len_result = check_function_call(checker, "len", len_args)
    jika len_result.kind == KIND_INT
        io.Write(io.Stdout, "len(string) = int: ‚úÖ PASS\n")
    lainnya
        io.Write(io.Stdout, "len(string): ‚ùå FAIL\n")
    akhir
    
    io.Write(io.Stdout, "\nüéâ ENHANCED CHECKER COMPLETE!\n")
    io.Write(io.Stdout, "‚úÖ Go-consistent type checking\n")
    io.Write(io.Stdout, "‚úÖ Array/Map access validation\n")
    io.Write(io.Stdout, "‚úÖ Built-in function checking\n")
    io.Write(io.Stdout, "‚úÖ Comprehensive error handling\n")
akhir

fungsi main() void
    test_enhanced_checker()
akhir

main()
